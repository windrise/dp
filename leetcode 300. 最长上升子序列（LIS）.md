# leetcode 300. 最长上升子序列（LIS）

**描述**： 给定一个无序的整数数组，找到其中最长上升子序列的长度。 

**输入示例**: [10,9,2,5,3,7,101,18]

**输出**： 4

**解释**: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

因为之前没怎么接触过动态规划，我觉着这个题最难想到的一点是用 dp[i] 表示 以第i个元素结尾的最长上升子序列的长度。

* 状态设计：dp[ i ] 代表以 a[ i ] 结尾的 LIS 的长度

* 状态转移：dp[ i ] = max {dp[ j ] + 1 ，dp[ i ] } (1 <= j <  i，a[ j ] < a[ i ])

* 边界处理：dp[ i ] = 1 (1 <= i <= n)

如果用dp[i]表示以第i个元素为头的最长上升子序列的长度，那么遍历就需要从后往前遍历。

dp数组中的每一个元素都是一个最优解。

```cpp
int[] dp = new int[nums.size()];
int ans=-1;  //记录最大dp值
for(int i=1;i<=nums.size();i++)
{
    dp[i]=1;  //边界初始条件（假设每个元素自成一个子序列） 
    for(int j=1;j<i;j++)
    {
        if(a[j] < a[i] && (dp[j]+1 > dp[i])){  //以j结尾的LIS并入 以i结尾的LIS 

            dp[i] = dp[j]+1; 
        } 
    } 
    ans = Math.max(ans, dp[i]); 
} 
return ans;
```







我觉着这个题最难想到的一点是用 dp[i] 表示 以第i个元素结尾的最长上升子序列的长度。

* 状态设计：dp[ i ] 代表以 a[ i ] 结尾的 LIS 的长度

* 状态转移：dp[ i ] = max {dp[ j ] + 1 ，dp[ i ] } (1 <= j <  i，a[ j ] < a[ i ])

* 边界处理：dp[ i ] = 1 (1 <= i <= n)

如果用dp[i]表示以第i个元素为头的最长上升子序列的长度，那么遍历就需要从后往前遍历。

dp数组中的每一个元素都是一个最优解。