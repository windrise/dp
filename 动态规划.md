# 动态规划刷题

## 概念

*动态规划*： 解决一类最优化问题的算法思想。动态规划将一个复杂问题分解成若干子问题，通过综合子问题的最优解来得到原问题的最优解。（注：可以再过程中会将子问题的解记录下来，方便之后利用）

*实现方式* ： 递归（自顶向下）和递推（自底向上）。 低：边界，顶：目标问题。

*重叠子问题*：一个问题可以被分解为若干个子问题，且这些子问题会重复出现。

*最优子结构*： 一个问题的最优解可以由其子问题的最优解有效地构造出来。

一个问题必须拥有重叠子问题和最优子结构才能用动态规划去解决。

*概念区别*：

1. 分治与动态规划： 分治与动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。不同的是，分治分解出来的子问题不会重叠，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如： 快速排序，分别处理左右序列，最后合并结果，无重叠子问题。分治解决的问题不一定是最优化问题，而dp解决的一定是最优化问题。
2. 贪心与动态规划：贪心与动态规划都要求原问题必须拥有最优子结构，区别在于，贪心法采用“自顶向下”，但并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选一个子问题去求解，没有选择的子问题就直接抛弃。显然不一定能够得到最优解。而动态规划会考虑所有子问题，并选择继承能够得到最优结果的那个，得到的一定是最优解。



## 1. 线性DP

### leetcode 300. 最长上升子序列（LIS）

  我觉着这个题最难想到的一点是用 dp[i] 表示 以第i个元素结尾的最长上升子序列的长度。

* 状态设计：dp[ i ] 代表以 a[ i ] 结尾的 LIS 的长度

* 状态转移：dp[ i ] = max {dp[ j ] + 1 ，dp[ i ] } (1 <= j <  i，a[ j ] < a[ i ])

* 边界处理：dp[ i ] = 1 (1 <= i <= n)

如果用dp[i]表示以第i个元素为头的最长上升子序列的长度，那么遍历就需要从后往前遍历。

dp数组中的每一个元素都是一个最优解。